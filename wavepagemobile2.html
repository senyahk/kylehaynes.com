<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Cursor Fluid Wave — exact look, mobile-safe</title>
<style>
  html, body { height:100%; margin:0; background:#0a0b10; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; } /* ← key add */
  .hint {
    position: fixed; left: 12px; bottom: 12px;
    color: #aab; font: 12px/1.3 system-ui, sans-serif; opacity: .75;
    user-select: none; pointer-events: none;
    background: rgba(0,0,0,.25); padding: 6px 8px; border-radius: 6px;
  }
  .error {
    position: fixed; inset: 0; display: grid; place-items: center;
    color: #fff; font: 16px/1.6 system-ui, sans-serif; text-align: center;
    padding: 24px;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Pixel-fixed size • Aspect-corrected • Rainbow ink • Speed-matched release</div>
<div id="err" class="error" style="display:none">Needs WebGL2 + EXT_color_buffer_float.</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { alpha:false, antialias:false, premultipliedAlpha:false });
  const errEl = document.getElementById('err');
  if (!gl) { errEl.style.display='grid'; return; }
  if (!gl.getExtension('EXT_color_buffer_float')) { errEl.style.display='grid'; return; }

  function fit() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = Math.floor(innerWidth * dpr);
    const h = Math.floor(innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
  }
  addEventListener('resize', fit, { passive:true }); fit();

  const sh = (t,src)=>{ const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)+'\n'+src); return s; };
  const prog = (vs,fs)=>{ const p=gl.createProgram(); gl.attachShader(p,sh(gl.VERTEX_SHADER,vs));
    gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; };
  const texRGBA16F=(w,h)=>{ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA16F,w,h,0,gl.RGBA,gl.HALF_FLOAT,null); return t; };
  const fbo=(w,h)=>{ const t=texRGBA16F(w,h), f=gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER,f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,t,0); return {fbo:f,tex:t,w,h}; };
  const dfbo=(w,h)=>{ const A=fbo(w,h), B=fbo(w,h); return { get read(){return A}, get write(){return B},
    swap(){ [A.tex,B.tex]=[B.tex,A.tex]; [A.fbo,B.fbo]=[B.fbo,A.fbo]; } }; };

  const VS=`#version 300 es
  precision highp float;
  const vec2 P[3]=vec2[3](vec2(-1.,-1.),vec2(3.,-1.),vec2(-1.,3.));
  out vec2 vUV; void main(){ vec2 p=P[gl_VertexID]; vUV=.5*(p+1.); gl_Position=vec4(p,0.,1.); }`;

  const FS_ADVECT=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity,uSource; uniform float uDt,uDissipation; uniform vec2 uTexel;
  void main(){ vec2 v=texture(uVelocity,vUV).xy; vec2 uv=vUV-uDt*v*uTexel; vec2 src=texture(uSource,uv).xy;
    o=vec4(src*uDissipation,0.,1.); }`;
  const FS_ADVECT_DYE=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity,uDye; uniform float uDt,uDissipation; uniform vec2 uTexel;
  void main(){ vec2 v=texture(uVelocity,vUV).xy; vec2 uv=vUV-uDt*v*uTexel; vec3 c=texture(uDye,uv).rgb*uDissipation; o=vec4(c,1.); }`;

  /* --------- ASPECT-CORRECTED SPLATS (unchanged) --------- */
  const FS_SPLAT_V=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity;
  uniform vec2  uPoint;
  uniform vec2  uForce;
  uniform float uRadius;   // normalized radius relative to min(simW, simH)
  uniform float uAspect;   // simW / simH
  void main(){
    vec2 base = texture(uVelocity, vUV).xy;
    vec2 d = vUV - uPoint;
    d.x *= uAspect;
    float r = uRadius;
    float s = exp( -dot(d,d) / (r*r) );
    o = vec4(base + uForce * s, 0., 1.);
  }`;

  const FS_SPLAT_D=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uDye;
  uniform vec2  uPoint;
  uniform vec3  uColor;
  uniform float uRadius;   // normalized radius relative to min(simW, simH)
  uniform float uAspect;   // simW / simH
  void main(){
    vec3 base = texture(uDye, vUV).rgb;
    vec2 d = vUV - uPoint;
    d.x *= uAspect;
    float r = uRadius;
    float s = exp( -dot(d,d) / (r*r) );
    o = vec4(base + uColor * s, 1.0);
  }`;
  /* -------------------------------------------------------- */

  const FS_DIVERGENCE=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uVelocity; uniform vec2 uTexel;
  void main(){
    vec2 L=texture(uVelocity,vUV-vec2(uTexel.x,0.)).xy;
    vec2 R=texture(uVelocity,vUV+vec2(uTexel.x,0.)).xy;
    vec2 B=texture(uVelocity,vUV-vec2(0.,uTexel.y)).xy;
    vec2 T=texture(uVelocity,vUV+vec2(0.,uTexel.y)).xy;
    float div=(R.x-L.x+T.y-B.y)*.5; o=vec4(div,0.,0.,1.);
  }`;
  const FS_CLEAR=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uPressure; uniform float uDissipation;
  void main(){ float p=texture(uPressure,vUV).x*uDissipation; o=vec4(p,0.,0.,1.); }`;
  const FS_JACOBI=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uPressure,uDivergence; uniform vec2 uTexel;
  void main(){
    float L=texture(uPressure,vUV-vec2(uTexel.x,0.)).x;
    float R=texture(uPressure,vUV+vec2(uTexel.x,0.)).x;
    float B=texture(uPressure,vUV-vec2(0.,uTexel.y)).x;
    float T=texture(uPressure,vUV+vec2(0.,uTexel.y)).x;
    float C=texture(uDivergence,vUV).x;
    float p=(L+R+B+T-C)*.25; o=vec4(p,0.,0.,1.);
  }`;
  const FS_GRADIENT=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uVelocity,uPressure; uniform vec2 uTexel;
  void main(){
    float L=texture(uPressure,vUV-vec2(uTexel.x,0.)).x;
    float R=texture(uPressure,vUV+vec2(uTexel.x,0.)).x;
    float B=texture(uPressure,vUV-vec2(0.,uTexel.y)).x;
    float T=texture(uPressure,vUV+vec2(0.,uTexel.y)).x;
    vec2 v=texture(uVelocity,vUV).xy - vec2(R-L, T-B)*.5; o=vec4(v,0.,1.);
  }`;
  const FS_DISPLAY=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uDye;
  void main(){ vec3 c=texture(uDye,vUV).rgb; c=c/(c+1.); o=vec4(c,1.); }`;

  const P_ADVECT_V=prog(VS,FS_ADVECT), P_ADVECT_DYE=prog(VS,FS_ADVECT_DYE),
        P_SPLAT_V=prog(VS,FS_SPLAT_V), P_SPLAT_D=prog(VS,FS_SPLAT_D),
        P_DIVERGENCE=prog(VS,FS_DIVERGENCE), P_CLEAR=prog(VS,FS_CLEAR),
        P_JACOBI=prog(VS,FS_JACOBI), P_GRADIENT=prog(VS,FS_GRADIENT),
        P_DISPLAY=prog(VS,FS_DISPLAY);

  function simSize(){ const s=.5; return { w:Math.max(16,(canvas.width*s)|0), h:Math.max(16,(canvas.height*s)|0) }; }
  let F=null;
  function alloc(){ const {w,h}=simSize(); return { velocity:dfbo(w,h), dye:dfbo(w,h), pressure:dfbo(w,h), divergence:fbo(w,h), w,h }; }
  function ensure(){ const s=simSize(); if (!F || F.w!==s.w || F.h!==s.h) F=alloc(); }
  function target(t){ gl.bindFramebuffer(gl.FRAMEBUFFER, t ? t.fbo : null); gl.viewport(0,0, t? t.w : canvas.width, t? t.h : canvas.height); }
  function tri(){ gl.drawArrays(gl.TRIANGLES,0,3); }
  gl.disable(gl.BLEND);

  // Pointer with smoothed velocity (normalized units per second)
  const velSmooth = 0.25;
  let ptr = { x:.5, y:.5, vx:0, vy:0, moved:false, down:false, lastMoveT: performance.now(), lastEventT: performance.now() };

  function setPtrFromEvent(e){
    const now = performance.now();
    const r=canvas.getBoundingClientRect();
    const px=(e.clientX - r.left) / r.width;
    const py=(e.clientY - r.top)  / r.height;
    const nx = px, ny = 1.0 - py;

    const dt = Math.max(1, now - ptr.lastEventT);
    const ivx = ((nx - ptr.x) * 1000) / dt;
    const ivy = ((ny - ptr.y) * 1000) / dt;

    ptr.vx = (1 - velSmooth) * ptr.vx + velSmooth * ivx;
    ptr.vy = (1 - velSmooth) * ptr.vy + velSmooth * ivy;

    ptr.x = nx; ptr.y = ny; ptr.moved = true; ptr.lastMoveT = now; ptr.lastEventT = now;
  }

  // --- Mobile-friendly pointer events (identical feel) ---
  function onDown(e){
    ptr.down = true;
    canvas.setPointerCapture(e.pointerId);
    setPtrFromEvent(e);
    e.preventDefault();
  }
  function onMove(e){
    // On desktop we still allow hover “painting”. On mobile we get moves only while captured.
    setPtrFromEvent(e);
    e.preventDefault();
  }
  function onUp(){
    ptr.down = false;
  }

  canvas.addEventListener('pointerdown', onDown, { passive:false });
  canvas.addEventListener('pointermove', onMove, { passive:false });
  canvas.addEventListener('pointerrawupdate', onMove, { passive:false }); // lower-latency if supported
  canvas.addEventListener('pointerup', onUp, { passive:true });
  canvas.addEventListener('pointercancel', onUp, { passive:true });

  // Tunables (unchanged)
  const params={
    dt:1/60,
    velDiss: 0.985,
    dyeDiss: 0.992,
    presDiss: 0.97,
    jacobi: 16,

    moveGain:     1800,
    releaseGain:  2200,

    RELEASE_DELAY: 140,
    minReleaseSpeed: 0.02,
    maxReleaseSpeed: 0.80,

    splatPx:   8,
    releasePx: 40,

    minScale: 0.65,
    baseDimForUnity: 1200,

    autoStartMs: 1500,
    autoMoveGain: 600,
    autoColorGain: 0.6,
    autoRadiusPx: 6
  };

  // HSV -> RGB (unchanged)
  function hsv2rgb(h, s, v) {
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0: return [v, t, p];
      case 1: return [q, v, p];
      case 2: return [p, v, t];
      case 3: return [p, q, v];
      case 4: return [t, p, v];
      case 5: return [v, p, q];
    }
  }
  let ink=[1,0,0];

  // Autopilot pointer (unchanged logic)
  let auto = { x: 0.5, y: 0.5 };

  function advectV(){ if(!F) return;
    gl.useProgram(P_ADVECT_V);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_V,'uDt'), params.dt);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_V,'uDissipation'), params.velDiss);
    gl.uniform2f(gl.getUniformLocation(P_ADVECT_V,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_V,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_V,'uSource'),1);
    target(F.velocity.write); tri(); F.velocity.swap();
  }
  function advectD(){ if(!F) return;
    gl.useProgram(P_ADVECT_DYE);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_DYE,'uDt'), params.dt);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_DYE,'uDissipation'), params.dyeDiss);
    gl.uniform2f(gl.getUniformLocation(P_ADVECT_DYE,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_DYE,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_DYE,'uDye'),1);
    target(F.dye.write); tri(); F.dye.swap();
  }
  function divergence(){ if(!F) return;
    gl.useProgram(P_DIVERGENCE);
    gl.uniform2f(gl.getUniformLocation(P_DIVERGENCE,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_DIVERGENCE,'uVelocity'),0);
    target(F.divergence); tri();
  }
  function clearPressure(){ if(!F) return;
    gl.useProgram(P_CLEAR);
    gl.uniform1f(gl.getUniformLocation(P_CLEAR,'uDissipation'), params.presDiss);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_CLEAR,'uPressure'),0);
    target(F.pressure.write); tri(); F.pressure.swap();
  }
  function pressureSolve(){ if(!F) return;
    gl.useProgram(P_JACOBI);
    gl.uniform2f(gl.getUniformLocation(P_JACOBI,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.divergence.tex); gl.uniform1i(gl.getUniformLocation(P_JACOBI,'uDivergence'),1);
    for(let i=0;i<params.jacobi;i++){
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_JACOBI,'uPressure'),0);
      target(F.pressure.write); tri(); F.pressure.swap();
    }
  }
  function subtractGradient(){ if(!F) return;
    gl.useProgram(P_GRADIENT);
    gl.uniform2f(gl.getUniformLocation(P_GRADIENT,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_GRADIENT,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_GRADIENT,'uPressure'),1);
    target(F.velocity.write); tri(); F.velocity.swap();
  }

  const loc = {
    splatV: {
      uPoint:     gl.getUniformLocation(P_SPLAT_V,'uPoint'),
      uForce:     gl.getUniformLocation(P_SPLAT_V,'uForce'),
      uRadius:    gl.getUniformLocation(P_SPLAT_V,'uRadius'),
      uAspect:    gl.getUniformLocation(P_SPLAT_V,'uAspect'),
      uVelocity:  gl.getUniformLocation(P_SPLAT_V,'uVelocity')
    },
    splatD: {
      uPoint:     gl.getUniformLocation(P_SPLAT_D,'uPoint'),
      uColor:     gl.getUniformLocation(P_SPLAT_D,'uColor'),
      uRadius:    gl.getUniformLocation(P_SPLAT_D,'uRadius'),
      uAspect:    gl.getUniformLocation(P_SPLAT_D,'uAspect'),
      uDye:       gl.getUniformLocation(P_SPLAT_D,'uDye')
    }
  };

  function splatV(x,y,fx,fy,r,aspect){ if(!F) return;
    gl.useProgram(P_SPLAT_V);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex);
    gl.uniform1i(loc.splatV.uVelocity, 0);
    gl.uniform2f(loc.splatV.uPoint, x, y);
    gl.uniform2f(loc.splatV.uForce, fx, fy);
    gl.uniform1f(loc.splatV.uRadius, r);
    gl.uniform1f(loc.splatV.uAspect, aspect);
    target(F.velocity.write); tri(); F.velocity.swap();
  }
  function splatD(x,y,r,g,b,rad,aspect){ if(!F) return;
    gl.useProgram(P_SPLAT_D);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex);
    gl.uniform1i(loc.splatD.uDye, 0);
    gl.uniform2f(loc.splatD.uPoint, x, y);
    gl.uniform3f(loc.splatD.uColor, r, g, b);
    gl.uniform1f(loc.splatD.uRadius, rad);
    gl.uniform1f(loc.splatD.uAspect, aspect);
    target(F.dye.write); tri(); F.dye.swap();
  }
  function show(){ if(!F) return;
    gl.useProgram(P_DISPLAY);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex); gl.uniform1i(gl.getUniformLocation(P_DISPLAY,'uDye'),0);
    target(null); tri();
  }

  function seed(){
    const now = performance.now() * 0.001;
    const hue = (now * 0.08) % 1;
    ink = hsv2rgb(hue, 1.0, 1.0);
    for(let i=0;i<6;i++){
      const x=.5+(Math.random()-.5)*.2, y=.5+(Math.random()-.5)*.2, k=.4+Math.random()*.3;
      const aspect = F.w / F.h;
      splatD(x,y, ink[0]*k, ink[1]*k, ink[2]*k, .01, aspect);
    }
  }

  ensure(); seed();

  let released=false;
  let lastT=performance.now();
  function loop(){
    ensure();
    const now=performance.now();
    const dtMs=Math.min(33, now-lastT); lastT=now;
    const steps=Math.max(1, Math.round(dtMs/(params.dt*1000)));

    const minDim = Math.min(innerWidth, innerHeight);
    const scale = Math.max(params.minScale, Math.min(1, minDim / params.baseDimForUnity));
    const resMin = Math.min(F.w, F.h);
    const normR_splat   = (params.splatPx   * scale) / resMin;
    const normR_release = (params.releasePx * scale) / resMin;
    const aspect = F.w / F.h;

    for(let i=0;i<steps;i++){
      const t = performance.now() * 0.001;
      const hue = (t * 0.08) % 1;
      ink = hsv2rgb(hue, 1.0, 1.0);

      const idleLong = (now - ptr.lastMoveT) > params.autoStartMs && !ptr.down;
      if (idleLong) {
        const dt = Math.max(1, dtMs);
        const t2  = now * 0.001;
        const ax = 0.5 + 0.27 * Math.sin(t2*0.35) * Math.cos(t2*0.17);
        const ay = 0.5 + 0.27 * Math.sin(t2*0.23 + 1.3) * Math.cos(t2*0.41);
        const avx = (ax - auto.x) * (1000 / dt);
        const avy = (ay - auto.y) * (1000 / dt);
        auto.x = ax; auto.y = ay;
        const fx = avx * params.autoMoveGain;
        const fy = avy * params.autoMoveGain;
        const r  = (params.autoRadiusPx ? (params.autoRadiusPx * scale) / resMin : normR_splat);
        splatV(auto.x, auto.y, fx, fy, r, aspect);
        splatD(auto.x, auto.y, ink[0]*params.autoColorGain, ink[1]*params.autoColorGain, ink[2]*params.autoColorGain, r*1.1, aspect);
      }

      if (ptr.moved || ptr.down){
        const fx = ptr.vx * params.moveGain;
        const fy = ptr.vy * params.moveGain;
        splatV(ptr.x, ptr.y, fx, fy, normR_splat, aspect);
        splatD(ptr.x, ptr.y, ink[0], ink[1], ink[2], normR_splat*1.2, aspect);
        ptr.moved=false;
      }

      const idle = (now - ptr.lastMoveT) > params.RELEASE_DELAY;
      if (!released && idle && !idleLong){
        const speed = Math.hypot(ptr.vx, ptr.vy);
        if (speed > params.minReleaseSpeed){
          const clamped = Math.min(speed, params.maxReleaseSpeed);
          const nx = ptr.vx / (speed || 1e-6);
          const ny = ptr.vy / (speed || 1e-6);
          const fx = nx * params.releaseGain * clamped;
          const fy = ny * params.releaseGain * clamped;

          splatV(ptr.x, ptr.y, fx, fy, normR_release, aspect);
          const gain = 0.35 + 0.35*clamped;
          splatD(ptr.x, ptr.y, ink[0]*gain, ink[1]*gain, ink[2]*gain, normR_release*0.9, aspect);
        }
        released=true;
      }
      if (!idle) released=false;

      advectV(); divergence(); clearPressure(); pressureSolve(); subtractGradient(); advectD();
    }
    show();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
