<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Cursor Fluid Wave — Tunable & Mobile-Safe</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #0a0b10;
    overflow: hidden;
    overscroll-behavior: none; /* prevent pull-to-refresh/overscroll */
    touch-action: none;        /* disable browser gestures globally */
  }
  /* place this in a <style> block after the fluid styles */
html, body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
             Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

.overlay .letter { font-family: inherit; }  /* ensures overlay uses the same */

  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    touch-action: none;        /* continuous pointer events */
    user-select: none;
    -webkit-user-select: none;
  }
  .hint {
    position: fixed; left: 12px; bottom: 12px;
    color: #aab; font: 12px/1.3 system-ui, sans-serif; opacity: .75;
    user-select: none; pointer-events: none;
    background: rgba(0,0,0,.25); padding: 6px 8px; border-radius: 6px;
  }
  .error {
    position: fixed; inset: 0; display: grid; place-items: center;
    color: #fff; font: 16px/1.6 system-ui, sans-serif; text-align: center;
    padding: 24px;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">V.v.V</div>
<div id="err" class="error" style="display:none">Needs WebGL2 + EXT_color_buffer_float.</div>

<script>
/* -------------------------------------------------------------------------
   CONFIG — tweak these knobs to control look & behavior
   (Grouped; each line documents what it does and a suggested range.)
---------------------------------------------------------------------------*/
const IDLE_ENABLED = true;     // Autopilot/idle swirl when not interacting. true/false

const params = {
  /* ---- SIMULATION / SOLVER ---- */
  dt: 1/60,                 // Time step in seconds. Smaller = smoother but more GPU work. Typical: 1/120…1/60
  jacobi: 32,               // Pressure iterations. Higher = less divergence, smoother flow. Typical: 8…32

  /* ---- DISSIPATION (appearance & motion persistence) ---- */
  velDiss: 0.985,           // Velocity decay per step. Lower = calmer/slower fluid. Typical: 0.97…0.995
  dyeDiss: 0.98,           // Color decay per step. Lower = longer trails. Typical: 0.98…0.999
  presDiss: 0.98,           // Pressure decay per step. Influences how long "pushes" linger. Typical: 0.95…0.99

  /* ---- BRUSH / INJECTION SIZES (screen-pixel based, scaled to sim res) ---- */
  splatPx: 15,               // Brush radius while moving. Thicker lines if higher. Typical: 3…15 px
  releasePx: 30,            // Brush radius on release burst. Typical: 10…50 px
  minScale: 0.65,           // Prevent brush getting too small on tiny screens. Typical: 0.5…0.9
  baseDimForUnity: 1500,    // Reference screen size used for brush scaling. Typical: 900…1500

  /* ---- INTERACTION GAINS (how hard input pushes the fluid) ---- */
  moveGain: 300,            // Strength while dragging ("jetstream"). Lower to calm it. Typical: 300…1800
  releaseGain: 200,         // Strength of the burst after stopping. Typical: 200…1500
  RELEASE_DELAY: 20,        // ms after last movement before release triggers. Typical: 80…250
  minReleaseSpeed: 0.02,    // Minimum cursor speed that can trigger a release. Typical: 0.01…0.05
  maxReleaseSpeed: 0.80,    // Clamp for release speed. Prevents huge blasts. Typical: 0.5…1.0

  /* ---- COLOR / RAINBOW ---- */
  rainbowSpeed: 0.1,       // Hue cycles per second. Lower = slower color change. Typical: 0.02…0.2

  /* ---- POINTER SMOOTHING ---- */
  velSmooth: 0.4,          // Blend factor for pointer velocity (0..1). Higher = smoother, less snappy. Typical: 0.1…0.4

  /* ---- AUTOPILOT / IDLE (used only if IDLE_ENABLED = true) ---- */
  autoStartMs: 1500,        // Idle time before autopilot begins. Typical: 1200…3000 ms
  autoMoveGain: 10,        // Autopilot movement strength. Typical: 100…800
  autoColorGain: 0.6,       // Autopilot color intensity. Typical: 0.2…1.0
  autoRadiusPx: 15           // Autopilot brush size (px). Typical: 3…10
};

/* ---- WALL / BOUNDARY SETTINGS (Proception-style edge collision) ---- */
const wall = {
  enabled: true,            // Toggle solid walls. true = collide with edges; false = free slip
  thicknessPx: 1,           // Thickness of the wall band in screen pixels. Typical: 2…8
  bounce: 0.6,              // Normal rebound. 0 = no-slip (sticks); 0.2…0.6 = bouncy feel
  friction: 0.1             // Tangential damping (0..1). Lower = stickier along the wall
};

/* -------------------------------------------------------------------------
   RUNTIME & MOBILE SAFETY
---------------------------------------------------------------------------*/
['gesturestart','gesturechange','gestureend'].forEach(ev =>
  document.addEventListener(ev, e => e.preventDefault(), { passive:false })
);

(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', {
    alpha:false, antialias:false, premultipliedAlpha:false, preserveDrawingBuffer:false
  });
  const errEl = document.getElementById('err');
  if (!gl) { errEl.style.display='grid'; return; }
  if (!gl.getExtension('EXT_color_buffer_float')) { errEl.style.display='grid'; return; }

  // Ignore resizes triggered during two-finger gestures
  let activePointers = 0;
  function fit(force=false) {
    if (activePointers > 0 && !force) return;
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = Math.floor(innerWidth * dpr);
    const h = Math.floor(innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) { canvas.width = w; canvas.height = h; }
  }
  addEventListener('resize', () => fit(false), { passive:true });
  fit(true);

  /* ---------------- GL HELPERS & SHADERS (do not normally edit) --------- */
  const sh = (t,src)=>{ const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)+'\n'+src); return s; };
  const prog = (vs,fs)=>{ const p=gl.createProgram(); gl.attachShader(p,sh(gl.VERTEX_SHADER,vs));
    gl.attachShader(p,sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; };
  const texRGBA16F=(w,h)=>{ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA16F,w,h,0,gl.RGBA,gl.HALF_FLOAT,null); return t; };
  const fbo=(w,h)=>{ const t=texRGBA16F(w,h), f=gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER,f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,t,0); return {fbo:f,tex:t,w,h}; };
  const dfbo=(w,h)=>{ const A=fbo(w,h), B=fbo(w,h); return { read:A, write:B, swap(){ const t=this.read; this.read=this.write; this.write=t; } }; };

  const VS=`#version 300 es
  precision highp float;
  const vec2 P[3]=vec2[3](vec2(-1.,-1.),vec2(3.,-1.),vec2(-1.,3.));
  out vec2 vUV; void main(){ vec2 p=P[gl_VertexID]; vUV=.5*(p+1.); gl_Position=vec4(p,0.,1.); }`;

  const FS_ADVECT=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity,uSource; uniform float uDt,uDissipation; uniform vec2 uTexel;
  void main(){ vec2 v=texture(uVelocity,vUV).xy; vec2 uv=vUV-uDt*v*uTexel; vec2 src=texture(uSource,uv).xy;
    o=vec4(src*uDissipation,0.,1.); }`;
  const FS_ADVECT_DYE=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity,uDye; uniform float uDt,uDissipation; uniform vec2 uTexel;
  void main(){ vec2 v=texture(uVelocity,vUV).xy; vec2 uv=vUV-uDt*v*uTexel; vec3 c=texture(uDye,uv).rgb*uDissipation; o=vec4(c,1.); }`;

  const FS_SPLAT_V=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uVelocity; uniform vec2 uPoint,uForce; uniform float uRadius,uAspect;
  void main(){ vec2 base=texture(uVelocity,vUV).xy; vec2 d=vUV-uPoint; d.x*=uAspect;
    float s=exp(-dot(d,d)/(uRadius*uRadius)); o=vec4(base + uForce*s,0.,1.); }`;

  const FS_SPLAT_D=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o;
  uniform sampler2D uDye; uniform vec2 uPoint; uniform vec3 uColor; uniform float uRadius,uAspect;
  void main(){ vec3 base=texture(uDye,vUV).rgb; vec2 d=vUV-uPoint; d.x*=uAspect;
    float s=exp(-dot(d,d)/(uRadius*uRadius)); o=vec4(base + uColor*s,1.); }`;

  const FS_DIVERGENCE=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uVelocity; uniform vec2 uTexel;
  void main(){ vec2 L=texture(uVelocity,vUV-vec2(uTexel.x,0.)).xy;
    vec2 R=texture(uVelocity,vUV+vec2(uTexel.x,0.)).xy;
    vec2 B=texture(uVelocity,vUV-vec2(0.,uTexel.y)).xy;
    vec2 T=texture(uVelocity,vUV+vec2(0.,uTexel.y)).xy;
    float div=(R.x-L.x+T.y-B.y)*.5; o=vec4(div,0.,0.,1.); }`;
  const FS_CLEAR=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uPressure; uniform float uDissipation;
  void main(){ float p=texture(uPressure,vUV).x*uDissipation; o=vec4(p,0.,0.,1.); }`;
  const FS_JACOBI=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uPressure,uDivergence; uniform vec2 uTexel;
  void main(){ float L=texture(uPressure,vUV-vec2(uTexel.x,0.)).x;
    float R=texture(uPressure,vUV+vec2(uTexel.x,0.)).x;
    float B=texture(uPressure,vUV-vec2(0.,uTexel.y)).x;
    float T=texture(uPressure,vUV+vec2(0.,uTexel.y)).x;
    float C=texture(uDivergence,vUV).x; float p=(L+R+B+T-C)*.25; o=vec4(p,0.,0.,1.); }`;
  const FS_GRADIENT=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uVelocity,uPressure; uniform vec2 uTexel;
  void main(){ float L=texture(uPressure,vUV-vec2(uTexel.x,0.)).x;
    float R=texture(uPressure,vUV+vec2(uTexel.x,0.)).x;
    float B=texture(uPressure,vUV-vec2(0.,uTexel.y)).x;
    float T=texture(uPressure,vUV+vec2(0.,uTexel.y)).x;
    vec2 v=texture(uVelocity,vUV).xy - vec2(R-L, T-B)*.5; o=vec4(v,0.,1.); }`;
  const FS_DISPLAY=`#version 300 es
  precision highp float; in vec2 vUV; out vec4 o; uniform sampler2D uDye;
  void main(){ vec3 c=texture(uDye,vUV).rgb; c=c/(c+1.); o=vec4(c,1.); }`;

/* ---- NEW: Boundary shader to enforce solid walls ---- */
const FS_BOUNDARY = `#version 300 es
precision highp float; in vec2 vUV; out vec4 o;
uniform sampler2D uVelocity;
uniform vec2 uTexel;              // 1/width, 1/height of VELOCITY FBO
uniform float uWallU, uWallV;     // normalized thickness in U and V
uniform float uBounce;            // normal component multiplier (0 = stick)
uniform float uFriction;          // tangential multiplier (0..1)

vec2 applyWall(vec2 v, bool left, bool right, bool bottom, bool top){
  vec2 outv = v;
  if (left || right)  { outv.x = -v.x * uBounce; outv.y = v.y * uFriction; }
  if (bottom || top)  { outv.y = -v.y * uBounce; outv.x = v.x * uFriction; }
  return outv;
}

void main(){
  vec2 v = texture(uVelocity, vUV).xy;
  bool left   = vUV.x < uWallU;
  bool right  = vUV.x > 1.0 - uWallU;
  bool bottom = vUV.y < uWallV;
  bool top    = vUV.y > 1.0 - uWallV;
  if (left || right || bottom || top) {
    v = applyWall(v, left, right, bottom, top);
  }
  o = vec4(v, 0.0, 1.0);
}`;

  const P_ADVECT_V=prog(VS,FS_ADVECT), P_ADVECT_DYE=prog(VS,FS_ADVECT_DYE),
        P_SPLAT_V=prog(VS,FS_SPLAT_V), P_SPLAT_D=prog(VS,FS_SPLAT_D),
        P_DIVERGENCE=prog(VS,FS_DIVERGENCE), P_CLEAR=prog(VS,FS_CLEAR),
        P_JACOBI=prog(VS,FS_JACOBI), P_GRADIENT=prog(VS,FS_GRADIENT),
        P_DISPLAY=prog(VS,FS_DISPLAY),
        P_BOUNDARY=prog(VS,FS_BOUNDARY);

  function simSize(){ const s=.5; return { w:Math.max(16,(canvas.width*s)|0), h:Math.max(16,(canvas.height*s)|0) }; }
  let F=null;
  function alloc(){ const {w,h}=simSize(); return { velocity:dfbo(w,h), dye:dfbo(w,h), pressure:dfbo(w,h), divergence:fbo(w,h), w,h }; }
  function ensure(){ const s=simSize(); if (!F || F.w!==s.w || F.h!==s.h) F=alloc(); }
  function target(t){ gl.bindFramebuffer(gl.FRAMEBUFFER, t ? t.fbo : null); gl.viewport(0,0, t? t.w : canvas.width, t? t.h : canvas.height); }
  function tri(){ gl.drawArrays(gl.TRIANGLES,0,3); }
  gl.disable(gl.BLEND);

  /* ---------------- UNIFORMS CACHE ---------------- */
  const loc = {
    splatV: {
      uPoint:gl.getUniformLocation(P_SPLAT_V,'uPoint'),
      uForce:gl.getUniformLocation(P_SPLAT_V,'uForce'),
      uRadius:gl.getUniformLocation(P_SPLAT_V,'uRadius'),
      uAspect:gl.getUniformLocation(P_SPLAT_V,'uAspect'),
      uVelocity:gl.getUniformLocation(P_SPLAT_V,'uVelocity')
    },
    splatD: {
      uPoint:gl.getUniformLocation(P_SPLAT_D,'uPoint'),
      uColor:gl.getUniformLocation(P_SPLAT_D,'uColor'),
      uRadius:gl.getUniformLocation(P_SPLAT_D,'uRadius'),
      uAspect:gl.getUniformLocation(P_SPLAT_D,'uAspect'),
      uDye:gl.getUniformLocation(P_SPLAT_D,'uDye')
    }
  };

  function splatV(x,y,fx,fy,r,aspect){ if(!F) return;
    gl.useProgram(P_SPLAT_V);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex);
    gl.uniform1i(loc.splatV.uVelocity, 0);
    gl.uniform2f(loc.splatV.uPoint, x, y);
    gl.uniform2f(loc.splatV.uForce, fx, fy);
    gl.uniform1f(loc.splatV.uRadius, r);
    gl.uniform1f(loc.splatV.uAspect, aspect);
    target(F.velocity.write); tri(); F.velocity.swap();
  }
  function splatD(x,y,r,g,b,rad,aspect){ if(!F) return;
    gl.useProgram(P_SPLAT_D);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex);
    gl.uniform1i(loc.splatD.uDye, 0);
    gl.uniform2f(loc.splatD.uPoint, x, y);
    gl.uniform3f(loc.splatD.uColor, r, g, b);
    gl.uniform1f(loc.splatD.uRadius, rad);
    gl.uniform1f(loc.splatD.uAspect, aspect);
    target(F.dye.write); tri(); F.dye.swap();
  }
  function show(){ if(!F) return;
    gl.useProgram(P_DISPLAY);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex); gl.uniform1i(gl.getUniformLocation(P_DISPLAY,'uDye'),0);
    target(null); tri();
  }

  /* ---------------- COLOR HELPERS ---------------- */
  function hsv2rgb(h, s, v) {
    const i = Math.floor(h * 6), f = h * 6 - i;
    const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
    switch (i % 6) { case 0: return [v, t, p]; case 1: return [q, v, p];
      case 2: return [p, v, t]; case 3: return [p, q, v]; case 4: return [t, p, v]; default: return [v, p, q]; }
  }

  /* ---------------- POINTER (single primary) ---------------- */
  let ptr = { x:.5, y:.5, vx:0, vy:0, moved:false, down:false, lastMoveT: performance.now(), lastEventT: performance.now() };

  function setPtrFromEvent(e){
    const now = performance.now();
    const r=canvas.getBoundingClientRect();
    const px=(e.clientX - r.left) / r.width;
    const py=(e.clientY - r.top)  / r.height;
    const nx = Math.min(1, Math.max(0, px));
    const ny = Math.min(1, Math.max(0, 1.0 - py));
    const dt = Math.max(1, now - ptr.lastEventT);
    const ivx = ((nx - ptr.x) * 1000) / dt;
    const ivy = ((ny - ptr.y) * 1000) / dt;
    const s = params.velSmooth; // smoothing blend (0..1)
    ptr.vx = (1 - s) * ptr.vx + s * ivx;
    ptr.vy = (1 - s) * ptr.vy + s * ivy;
    ptr.x = nx; ptr.y = ny; ptr.moved = true; ptr.lastMoveT = now; ptr.lastEventT = now;
  }

  function onDown(e){
    if (!e.isPrimary) { e.preventDefault(); return; } // ignore second finger
    activePointers++;
    ptr.down = true;
    canvas.setPointerCapture(e.pointerId);
    setPtrFromEvent(e);
    e.preventDefault();
  }
  function onMove(e){
    if (!e.isPrimary) { e.preventDefault(); return; }
    setPtrFromEvent(e);
    e.preventDefault();
  }
  function onUp(e){
    if (e.isPrimary) { ptr.down = false; }
    activePointers = Math.max(0, activePointers - 1);
  }

  canvas.addEventListener('pointerdown', onDown, { passive:false });
  canvas.addEventListener('pointermove', onMove, { passive:false });
  canvas.addEventListener('pointerrawupdate', onMove, { passive:false });
  canvas.addEventListener('pointerup', onUp, { passive:true });
  canvas.addEventListener('pointercancel', onUp, { passive:true });

  /* ---------------- SEED ---------------- */
  let ink=[1,0,0];
  function seed(){
    const now = performance.now() * 0.001;
    const hue = (now * params.rainbowSpeed) % 1;
    ink = hsv2rgb(hue, 1.0, 1.0);
    ensure();
    for(let i=0;i<6;i++){
      const x=.5+(Math.random()-.5)*.2, y=.5+(Math.random()-.5)*.2, k=.4+Math.random()*.3;
      const aspect = F.w / F.h;
      splatD(x,y, ink[0]*k, ink[1]*k, ink[2]*k, .01, aspect);
    }
  }

  ensure(); seed();

  /* ---------------- MAIN LOOP ---------------- */
  let released=false;
  let lastT=performance.now();

  function advectV(){ if(!F) return;
    gl.useProgram(P_ADVECT_V);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_V,'uDt'), params.dt);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_V,'uDissipation'), params.velDiss);
    gl.uniform2f(gl.getUniformLocation(P_ADVECT_V,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_V,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_V,'uSource'),1);
    target(F.velocity.write); tri(); F.velocity.swap();
  }
  function advectD(){ if(!F) return;
    gl.useProgram(P_ADVECT_DYE);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_DYE,'uDt'), params.dt);
    gl.uniform1f(gl.getUniformLocation(P_ADVECT_DYE,'uDissipation'), params.dyeDiss);
    gl.uniform2f(gl.getUniformLocation(P_ADVECT_DYE,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_DYE,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.dye.read.tex); gl.uniform1i(gl.getUniformLocation(P_ADVECT_DYE,'uDye'),1);
    target(F.dye.write); tri(); F.dye.swap();
  }
  function divergence(){ if(!F) return;
    gl.useProgram(P_DIVERGENCE);
    gl.uniform2f(gl.getUniformLocation(P_DIVERGENCE,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_DIVERGENCE,'uVelocity'),0);
    target(F.divergence); tri();
  }
  function clearPressure(){ if(!F) return;
    gl.useProgram(P_CLEAR);
    gl.uniform1f(gl.getUniformLocation(P_CLEAR,'uDissipation'), params.presDiss);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_CLEAR,'uPressure'),0);
    target(F.pressure.write); tri(); F.pressure.swap();
  }
  function pressureSolve(){ if(!F) return;
    gl.useProgram(P_JACOBI);
    gl.uniform2f(gl.getUniformLocation(P_JACOBI,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.divergence.tex); gl.uniform1i(gl.getUniformLocation(P_JACOBI,'uDivergence'),1);
    for(let i=0;i<params.jacobi;i++){
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_JACOBI,'uPressure'),0);
      target(F.pressure.write); tri(); F.pressure.swap();
    }
  }
  function subtractGradient(){ if(!F) return;
    gl.useProgram(P_GRADIENT);
    gl.uniform2f(gl.getUniformLocation(P_GRADIENT,'uTexel'), 1/F.w, 1/F.h);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex); gl.uniform1i(gl.getUniformLocation(P_GRADIENT,'uVelocity'),0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, F.pressure.read.tex); gl.uniform1i(gl.getUniformLocation(P_GRADIENT,'uPressure'),1);
    target(F.velocity.write); tri(); F.velocity.swap();
  }

  // ---- NEW: Apply solid-wall boundary conditions to velocity ----
  function applyBoundaries(){
    if (!wall.enabled || !F) return;
    gl.useProgram(P_BOUNDARY);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, F.velocity.read.tex);
    gl.uniform1i(gl.getUniformLocation(P_BOUNDARY,'uVelocity'), 0);
    gl.uniform2f(gl.getUniformLocation(P_BOUNDARY,'uTexel'), 1/F.w, 1/F.h);
    const resMin = Math.min(F.w, F.h);
    const wallU = wall.thicknessPx / resMin;
    const wallV = wallU;
    gl.uniform1f(gl.getUniformLocation(P_BOUNDARY,'uWallU'), wallU);
    gl.uniform1f(gl.getUniformLocation(P_BOUNDARY,'uWallV'), wallV);
    gl.uniform1f(gl.getUniformLocation(P_BOUNDARY,'uBounce'), wall.bounce);
    gl.uniform1f(gl.getUniformLocation(P_BOUNDARY,'uFriction'), wall.friction);
    target(F.velocity.write); tri(); F.velocity.swap();
  }

  function loop(){
    ensure();
    const now=performance.now();
    const dtMs=Math.min(33, now-lastT); lastT=now;
    const steps=Math.max(1, Math.round(dtMs/(params.dt*1000)));

    // pixel -> normalized radii (constant visual size across resolutions)
    const minDim = Math.min(innerWidth, innerHeight);
    const scale = Math.max(params.minScale, Math.min(1, minDim / params.baseDimForUnity));
    const resMin = Math.min(F.w, F.h);
    const normR_splat   = (params.splatPx   * scale) / resMin;
    const normR_release = (params.releasePx * scale) / resMin;
    const aspect = F.w / F.h;

    for(let i=0;i<steps;i++){
      const t = performance.now() * 0.001;
      const hue = (t * params.rainbowSpeed) % 1;
      ink = hsv2rgb(hue, 1.0, 1.0);

      // Idle autopilot (optional)
      const idleLong = IDLE_ENABLED && (now - ptr.lastMoveT) > params.autoStartMs && !ptr.down;
      if (idleLong) {
        const dt = Math.max(1, dtMs);
        const t2  = now * 0.001;
        const ax = 0.5 + 0.27 * Math.sin(t2*0.35) * Math.cos(t2*0.17);
        const ay = 0.5 + 0.27 * Math.sin(t2*0.23 + 1.3) * Math.cos(t2*0.41);
        const avx = (ax - 0.5) * (1000 / dt);
        const avy = (ay - 0.5) * (1000 / dt);
        const fx = avx * params.autoMoveGain;
        const fy = avy * params.autoMoveGain;
        const r  = (params.autoRadiusPx ? (params.autoRadiusPx * scale) / resMin : normR_splat);
        splatV(ax, ay, fx, fy, r, aspect);
        const rgb = hsv2rgb(((t2*params.rainbowSpeed)+0.5)%1, 1, 1);
        splatD(ax, ay, rgb[0]*params.autoColorGain, rgb[1]*params.autoColorGain, rgb[2]*params.autoColorGain, r*1.1, aspect);
      }

      // Continuous injection from pointer movement
      if (ptr.moved || ptr.down){
        const fx = ptr.vx * params.moveGain;
        const fy = ptr.vy * params.moveGain;
        splatV(ptr.x, ptr.y, fx, fy, normR_splat, aspect);
        splatD(ptr.x, ptr.y, ink[0], ink[1], ink[2], normR_splat*1.2, aspect);
        ptr.moved=false;
      }

      // Release burst after pause
      const idle = (now - ptr.lastMoveT) > params.RELEASE_DELAY;
      if (!released && idle && !idleLong){
        const speed = Math.hypot(ptr.vx, ptr.vy);
        if (speed > params.minReleaseSpeed){
          const clamped = Math.min(speed, params.maxReleaseSpeed);
          const nx = ptr.vx / (speed || 1e-6);
          const ny = ptr.vy / (speed || 1e-6);
          const fx = nx * params.releaseGain * clamped;
          const fy = ny * params.releaseGain * clamped;
          splatV(ptr.x, ptr.y, fx, fy, normR_release, aspect);
          const gain = 0.35 + 0.35*clamped;
          splatD(ptr.x, ptr.y, ink[0]*gain, ink[1]*gain, ink[2]*gain, normR_release*0.9, aspect);
        }
        released=true;
      }
      if (!idle) released=false;

      // Core steps
      advectV();
      divergence();
      clearPressure();
      pressureSolve();
      subtractGradient();
      applyBoundaries(); // enforce solid walls
      advectD();
    }
    show();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Handle context loss gracefully
  canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); }, false);
  canvas.addEventListener('webglcontextrestored', ()=>{ fit(true); F=null; ensure(); }, false);
})();
</script>

<!-- ======================= OVERLAY TEXT (added without modifying fluid code) ======================= -->
<style>
  .overlay { position: fixed; inset: 0; z-index: 10; pointer-events: none; }
  .overlay .letter { position: absolute; font-size: clamp(24px, 6vw, 48px); white-space: pre; color: #ffffff; text-shadow: 0 0 6px rgba(255,255,255,0.25); }
  .overlay .kyle-link { pointer-events: auto; font-weight: 700; text-decoration: none; --hue: 0; color: hsl(var(--hue),100%,75%); text-shadow: 0 0 6px hsla(var(--hue),100%,60%,0.7), 0 0 14px hsla(var(--hue),100%,60%,0.35), 0 0 28px hsla(var(--hue),100%,60%,0.15); animation: hue-shift 12s linear infinite; }
  @keyframes hue-shift { from { --hue: 0; } to { --hue: 360; } }
</style>
<div id="layer" class="overlay" aria-hidden="false"></div>
<script>
  // Text: keep exact placement from your original index
  (function(){
    const lines = [
      "hi my name is kyle",
      ""
    ];
    const container = document.getElementById('layer');

    function layout(){
      container.innerHTML='';
      const centerX = window.innerWidth / 2;
      const lineHeight = window.innerHeight / 3;
      const spacingY = 60;

      const placed = [];
      lines.forEach((line, li)=>{
        // temp measure spans
        const meas = line.split('').map(ch=>{
          const s=document.createElement('span'); s.className='letter'; s.textContent = ch===' ' ? '\u00A0' : ch; container.appendChild(s); return {el:s};
        });
        meas.forEach(m=>{ const r=m.el.getBoundingClientRect(); m.width=r.width; m.height=r.height; });
        const total = meas.reduce((a,m)=>a+m.width,0);
        let x = centerX - total/2; const y = lineHeight + spacingY*li;
        meas.forEach(m=>{ m.x=x; m.y=y; m.el.style.transform=`translate(${m.x}px, ${m.y}px)`; placed.push(m); x += m.width; });
      });

      // find kyle
      let idx=[]; placed.forEach((p,i)=>{ if(p.el.textContent.toLowerCase()==='k' && placed[i+1]?.el.textContent.toLowerCase()==='y' && placed[i+2]?.el.textContent.toLowerCase()==='l' && placed[i+3]?.el.textContent.toLowerCase()==='e'){ idx=[i,i+1,i+2,i+3]; }});
      if(idx.length===4){
        const first=placed[idx[0]], last=placed[idx[3]];
        const link=document.createElement('a'); link.href='resume.pdf'; link.target='_blank'; link.rel='noopener noreferrer'; link.className='letter kyle-link'; link.textContent='kyle'; link.style.transform=`translate(${first.x}px, ${first.y}px)`;
        // hide originals
        idx.forEach(i=>{ placed[i].el.style.visibility='hidden'; });
        container.appendChild(link);
      }
    }

    layout();
    addEventListener('resize', layout);
  })();
</script>
</body>
</html>

